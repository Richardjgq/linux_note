# **Intro介绍**

> 介绍 : [http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/intro.pdf)

如果你已经对计算机操作系统有一定的了解 , 那么当一个计算机程序运行时 , 你的脑子里应该对这个过程有一定的概念了 . 如果没有了解 , 那这本书\(以及相应方面的内容\)对你来说可能是很难理解的 . 因此找些必要的相关知识背景的书来给你后续阅读此书做铺垫吧 , 这里推荐了 : 几个作者 , Patt/Patel , Bryant/O’Hallaron , 搜索到了他们的书 :

&lt;计算机系统概论&gt;

&lt;深入理解计算机系统&gt;

那么程序运行时会发生什么呢?

一个正在运行中的程序做的事情很简单 : 执行指令 , 每秒钟约百万次\(现今约百亿\) . 处理器从存储器中取出指令 , 进行解码\(即让机器知道程序要干什么——机器码\) , 然后去执行指令\(即让程序去做它应该要做的事情 , 比如将两个数加在一起 , 访问内存 , 状态检测 , 功能跳转等等\) . 当指令执行完毕 , 处理器将跳转到下一个指令 , 后面还有更多 , 直到程序最终完成 .

至此 , 我们只是简单的描述了一下冯诺依曼模型的基本运算 . 听起来很简单 , 但是这里 , 我们要学习的不是这些 , 许多在程序运行时我们看不见的东西，正是这些看不见的东西让操作系统更加的易于使用 , 这才是我们要讨论的 .

> **关键问题 - **如何虚拟化资源
>
> 在本书中我们围绕的一个简单的中心问题就是 : 操作系统如何虚拟化资源 ? 这就是我们的问题的核心 . 为什么这不是操作系统\(OS\)的主要问题 , 答案应该很明显 : 它只是让操作系统易于使用 . 因此 , 我们的焦点是 : 操作系统是通过什么机制和策略实现虚拟化的 ? 操作系统是怎样运行的如此高效 ? 又需要什么样的硬件支持呢 ?
>
> 我们说"问题的关键" , 正如盒子里的阴影部分 , 我们正试着找到在构建操作系统中的一种解决具体问题的方法 . 因此 , 在这个特定主题的书里 , 你也许会发现一个或者更多高于中心问题的难题 . 当然 , 在本章的小节中 , 会给出目前的解决方案 , 或者至少是解决问题的关键点 .

有一个软件的主体 , 实际上 ,  它是为了让程序易于运行\(就是让你感觉在同一时间运行了很多东西\) , 让程序共享内存 , 能够与设备交互 , 以及许多其他的功能 . 这个软件的主体就被称为**操作系统** . 它负责确保操作系统以易于使用的方式来正确高效的运行 .

操作系统运行的主要方式就是通过我们称之为虚拟化的一个通用技术 . 也就是说 , 操作系统掌握着物理资源\(如处理器,内存,磁盘\)并将它转化为更加比原来更高效 , 普遍 , 易于使用的虚拟形式 . 因此 , 我们更偏向于把操作系统当做一个虚拟机 .

当然，为了让用户能告知OS做什么从而去使用虚拟机器的资源（比如运行一个程序，或分配内存，或者读取一个文件），OS提供了一些供用户调用的接口。实际上一个典型的操作系统，是开放几百个系统调用给应用程序的。因为OS提供的这些调用，沟通内存和设备，和其他一些相关的东西，有时我们也可以说OS为应用程序提供了一个标准库。

最后 , 因为虚拟化让许多程序得以运行\(共享CPU\) , 许多程序可以同时访问他们自己的指令和数据\(共享内存\) , 许多程序连接到设备\(共享磁盘等等\) , 所以OS有时也被认为是一个资源管理器 . CPU , 内存和磁盘都是系统的资源 , 他们也是操作系统管理的那些资源中的一部分 , 不停地做着高效的或者是公平的或者是其他很多预想可能会有的事情 . 懂得这些操作系统的成员一些会更好 . 来看看一些例子 .

```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int main(int argc, char *argv[]) {
    if (argc != 2) {
    fprintf(stderr, "usage: cpu <string>\n");
    exit(1);
    }
    char *str = argv[1];

    while (1) {
    printf("%s\n", str);
    Spin(1);
    }
    return 0;
}
```

这是一个循环打印代码的例子 .

#### 虚拟化CPU

前面的代码是我们的第一个程序 , 它所做的事情并不多 . 实际上 , 它所做的所有的事情只有一件 , 就是调用Spin\(\) . 它所做的是重复的判断时间并且每隔一秒执行一次 , 打印出来的字符就是用户在命令行里面传入的 , 并且一直执行下去 .

以cpu.c保存该代码并且在一个系统上用单处理器\(也就是所谓的CPU\)编译执行 :

```
gcc -o cpu cpu.c -Wall
./cpu "A"
A
A
A
A
ˆC
```

程序重复的检查时间 , 每当一秒钟过去 , 系统就开始执行程序 . 每当一秒钟过去 , 代码便打印用户输入的字符\(如字母“A”\) . 这个程序会一直执行这 , 只有按下"Control-c"\(Unix类系统前台运行程序的终止方法\)才能终止 . 现在 , 让我们再跑一次程序 , 但是这次我们用相同的程序运行一些不同的例子 :

```
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

同时运行多个程序 .

现在开始变得有点意思了 . 尽管我们只有一个处理器 , 但是不知道为什么 , 这四个进程看起来似乎时同时进行的 . 这个神奇的过程是怎么产生的呢 ? 实际上由于硬件的支持 , 操作系统让我们产生了一种错觉——系统拥有大量的虚拟CPU . 将单个CPU\(或者小的一组\)转变成似乎时无限多个CPU , 从而让多个程序似乎可以同步运行 , 这就是我们所说的虚拟化CPU , 也是本书第一个主要部分的重点 , 虚拟化 .

当然 , 启动进程 , 终止进程 , 或者告诉操作系统运行哪个进程 , 需要有一些接口能让我们将目的告知操作系统\(OS\) . 在整本书中都会讨论这些接口 , 它们就是用户与操作系统交互的主要途径 .

也许你已经注意到了 , 这种一次运行多个进程的能力带来了一系列新的问题 . 比如 , 如果两个程序要在一个特定的时间运行 , 应该运行哪个 ? OS的一种策略回答了这个问题 . 操作系统中采用各种策略来应对很多不同场景的不同类型的问题 . 因此 , 我们将要通过学习这些策略来了解操作系统所采用的基础机制\(比如同步运行多个程序的能力\) . 所以 , OS的角色就是作为一个资源管理器 .

#### 虚拟内存

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include "common.h"

int
main(int argc, char *argv[])
{
    if (argc != 2) { 
    fprintf(stderr, "usage: mem <value>\n"); 
    exit(1); 
    } 
    int *p;                   // memory for pointer is on "stack"
    p = malloc(sizeof(int));  // malloc'd memory is on "heap"
    assert(p != NULL);
    printf("(pid:%d) addr of p:        %llx\n", (int) getpid(), 
       (unsigned long long) &p);
    printf("(pid:%d) addr stored in p: %llx\n", (int) getpid(), 
       (unsigned long long) p);
    *p = atoi(argv[1]);       // assign value to addr stored in p
    while (1) {
    Spin(1);
    *p = *p + 1;
    printf("(pid:%d) value of p: %d\n", getpid(), *p);
    }

    return 0;
}
```

一个访问内存的程序\(mem.c\) .

现在 , 让我们来考虑内存 . 现代化机器呈现的物理内存的模型是非常简单的 . 内存就是一个字节数组 . 读取内存 , 必须要一个指定地址能够访问存储在内存中数据 . 要写入\(更新\)内存 , 还需要将特定的数据写入到指定的地址 .

一个进程运行的所有时间内 , 内存都是可以被访问的 . 程序将它的所有数据结构都存放在内存中 , 并通过一系列指令来访问它们 , 就像在它们工作的时候 , 用载入,存储或者其他明确的指令访问内存 . 不要忘了每个指令也都是存放在内存中的 , 因此 , 在每个指令的取出时内存也是可以访问的 .

让我们来看看前面通过malloc\(\)函数分配内存的程序 . 这里是程序的输出 :

```
# 别忘记编译代码
./make-mem.csh
# 输出内容
➜  code.intro ./mem test
(pid:63018) addr of p:        7fff5fbffa28
(pid:63018) addr stored in p: 100100020
(pid:63018) value of p: 1
(pid:63018) value of p: 2
(pid:63018) value of p: 3
(pid:63018) value of p: 4
(pid:63018) value of p: 5
^C
```

这个程序做了几个事情 :

* 首先 , 它分配了一下内存 . 
* 然后 , 它打印了内存的地址 . 
* 接着将数字写入新分配的内存的最开始的位置 . 

最终进行循环 , 每隔一秒就将存储在指针指向的地址的数值增加 , 每次状态打印的时候 , 它也打印出来当前运行进程的进程标识符\(即PID\) . 这个PID就是该运行程序的特定标志 .

再次运行多个实例来看看发生了什么 :

```
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
(24113) p: 4
(24114) p: 4
...
```

这个例子中可以看到每个进程都是从相同的地址\(00200000\)开始分配内存 , 而且似乎是独立地去更新00200000处的数值的 . 似乎每个进程运行时 , 它们都拥有各自私有的内存 , 而不是与其他正在运行的进程共享相同的物理内存 .

实际上 , 操作系统中真正发生的事情是虚拟内存 . 每个进程都访问它们自己的私有的虚拟地址空间\(有时候就直接被称为地址空间\) , 操作系统将这些虚拟地址空间以某种方式映射到机器的物理内存 . 一个运行的程序引用的内存不会影响其他进程的地址空间\(或者操作系统本身\) , 就正在运行的程序而言 , 它独自占有所有的物理内存 . 然而 , 事实却是 , 物理内存是一个由操作系统管理的共享资源 . 这究竟是如何实现的也是本书第一部分的主体 , 虚拟化 .

#### 并发

本书的另一个主题就是并发 . 我们通过这个概念来指代在同一个程序中一次性进行多个工作给主机带来而且必须得到解决的问题 . 并发的问题最初是操作系统自身范围内出现的 , 你可以从上面的例子中看到 , 操作系统同时做着许多事情 , 首先运行一个进程 , 然后另一个... . 事实证明 , 这样做带来了一些更深层次的而且很好玩的问题 .

并发的问题已经不再仅仅局限于操作系统本身 , 现在的多线程程序也存在相同的问题 , 现在让我们来演示一个多线程程序 :

```c
#include <stdio.h>
#include <stdlib.h>
#include "common_threads.h"

volatile int counter = 0; 
int loops;

void *worker(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
    counter = counter + 1;
    }
    pthread_exit(NULL);
}

int main(int argc, char *argv[]) {
    if (argc != 2) { 
    fprintf(stderr, "usage: threads <loops>\n"); 
    exit(1); 
    } 
    loops = atoi(argv[1]);
    pthread_t p1, p2;
    printf("Initial value : %d\n", counter);
    Pthread_create(&p1, NULL, worker, NULL); 
    Pthread_create(&p2, NULL, worker, NULL);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);
    printf("Final value   : %d\n", counter);
    return 0;
}
```

也许你现在还不能完全理解这个程序 , 但是它的基本思想很简单 . 主程序用Pthread create\(\)函数创建了两个线程 . 你可以把一个线程当做是在相同内存的功能函数 , 就和其它功能函数一样 , 这里的多线程就是一次执行不止一个功能函数 . 在这个例子中 , 每个线程从函数worker\(\)函数开始 , worker函数作为循环的计数器 .

我们输入1000来设定循环 , 然后运行这个程序 , 下面就是输出结果 . 循环值会确定两个worker函数循环中共享的计数器的增长次数 :

```
➜  code.intro ./threads.v0 1000
Initial value : 0
Final value   : 2000
```

> 官网给的代码稍有错误 , 编译时会报错 , 引入common\_threads.h等稍作修改即可 .

正如你可能猜到的 , 当两个线程结束 , 最终计数器的值是2000 , 每个线程都给计数器增加了1000次 . 的确 , 输入循环的值为N , 我们运行程序得到最终输出就是2N . 但是事情不会这么简单 , 正如程序自己给出的结果所示 . 让我们输入一个更大的值来运行相同的程序 , 看看发生的结果 :

```
➜  code.intro ./threads.v0 10000
Initial value : 0
Final value   : 15821
➜  code.intro ./threads.v0 10000
Initial value : 0
Final value   : 18797
```

这次运行 , 我们输入的值时10000 , 程序最终给出的结果不是我们想要的20000 , 而是15821 . 于是 , 我们又一次运行 , 我们不仅得到了一个错误的结果 , 而且还输出了一个和上次不同的数值 . 事实上 , 如果你输入很大的数值一遍又一遍的运行程序循环 , 你也行会发现你有时候会得到正确的结果 , 为什么会这样 ?

事实证明这些奇怪的未预期的结果跟每次如何执行指令相关 . 不幸的是 , 上面程序共享的计数器递增的关键部分包涵三条指令 : 一个是从内存加载计数器的值到寄存器 , 一个是增加 , 一个是将它存入内存 . 因为这三条指令不是原子执行的\(即一次执行所有\) , 所以才发生了奇怪的事情 .

> **关键问题** - 如何构建正确的并发程序
>
> 在同一个内存空间有多个并发执行的线程 , 我们应该如何构建一个正确的工作程序 ? 需要什么操作系统原语 ? 硬件应该提供什么机制 ? 我们怎样使用它们来解决并发的问题 ?

这里编译了例子代码v1版本 , 输出正常了 :

```
➜  code.intro ./threads.v1 100000
Initial value : 0
Final value   : 200000
```

并发的问题我们将在本书的第二部分详细讨论 .

#### 持久性

三观的第三部分就是讨论持久性 . 在系统内存里面 , 数据很容易丢失 , 比如动态存储器的可变存储 , 在系统崩溃或者断电时 , 内存上的所有数据都会丢失 . 因此 , 我们需要软硬件可以持久的存储数据 . 用户很关心他们自己的数据 , 因而对于任何系统来说持久性存储非常重要 .

硬盘自带输入输出接口或者I/O设备 , 在现代系统中 , 硬盘驱动器是常见的存储长久信息的容器 , 尽管固态硬盘也在这方面取得了一些进展 . 操作系统上通常用来管理磁盘的软件被称为文件系统 , 它是负责以可靠且有效的方式存储用户在系统磁盘上创建的所有文件 .

与操作系统对CPU和内存的抽象不同的是 , 系统不会为每个应用程序创建一个私有且虚拟化的磁盘 . 相反 , 它假定用户很多时候想要共享文件中的信息 . 举个例子 , 你写一个C程序 , 首先你要使用一个编辑器\(比如`Emacs`\)来创建和编辑这个c文件\(命令是`emacs -nw main.c`\) . 代码写完之后 , 你需要用编译器来将源代码转化为一个可执行文件\(`gcc -o main main.c`\) . 当你完成这些工作之后 , 就可以运行这个新生成的可执行文件\(`./main`\) . 因此 , 你可以看到在不同的进程中文件是如何共享的 . 首先 , Emacs创建一个文件作为编译器的输入 , 编译器使用这个输入的文件创建一个新的可执行文件\(这里面更多的步骤详见编译原理\) . 最后 , 可执行文件被运行 . 到此 , 一个新的进程生成了 .

为了更好的理解 , 看一下下面的代码 , 一个输出"hello world"的程序 :

```c
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/types.h>

int
main(int argc, char *argv[])
{
    int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
    assert(fd > -1);
    int rc = write(fd, "hello world\n", 13);
    assert(rc == 13);
    close(fd);
    return 0;
}
```

为了完成这个任务 , 程序用了三个系统调用 . 第一个是open\(\) , 创建和打开文件 , 第二个是write\(\) , 向文件中写入数据 , 第三个是close\(\) , 简单的关闭文件防止写入更多的数据 . 这些系统调用直接与文件系统连 , 然后处理请求并返回错误码给用户 .

> **关键问题** - 如何构持久存储数据
>
> 文件系统是操作系统负责管理持久数据的一部分 . 保证正确执行需要什么技术 ? 高性能的运行需要什么机制和策略 ? 在面对软硬件故障的时候 , 如何实现可靠性 ?

你也可能会想 , 操作系统在写入磁盘时做了什么 ? 我们来看看 . 文件系统做了一些均等的事情 : 首先确定新的数据在磁盘上的存储位置 , 然后保持它在文件系统结构中轨迹 . 这些工作需要发出I/O请求到底层存储设备 , 然后读取现有的结构或者更新它们 . 任何一个写过设备驱动程序的人都知道 , 让一个设备按照你的意愿去做某件事是一个繁复的过程。这需要有对设备底层接口和它的精确语义的深入了解 . 幸运的是 , OS通过自身的系统调用提供了一个标准化的简单方法来访问设备 . 因此 , OS有时也被看做是一个标准库 .

当然 , 对于访问设备和文件系统如何持久地在上述设备上管理数据 , 其实还有更多的详细内容 . 由于性能的原因 , 大多数文件系统首先延迟处理写操作 , 希望能批量处理 . 为了处理系统在写入数据时出现崩溃的问题 , 大多数文件系统采用某种错综复杂的写入协议 , 如日志 , 写复制 , 仔细地顺序写入磁盘来确保如果在写失败发生时 , 系统可以在此之后回复到一个合理的状态 . 为了不同寻常的操作效率 , 文件系统采用许多不同的数据结构和访问方法——从简单的列表到复制的B树 . 如果这些也都没理解 , 我们将在本书的第三部分\(持久性\)针对这些进行很多详细的讨论 . 我们会总体的讨论设备 , I/O , 然后是磁盘 , RAIDs和文件系统 .

#### 设计目标

所以现在你已经知道一个操作系统实际上做了什么 : 它需要物理资源\(如CPU , 内存或磁盘\) , 并对其进行虚拟化 . 它处理与并发有关的棘手的问题 . 它存储文件 , 并保证其持续性和数据的安全 . 鉴于我们希望建立这样一个系统 , 我们希望有一些目标 , 以帮助我们的设计和实施为重点 , 并作出必要的权衡 , 找到正确的权衡取舍是构建系统的关键 .

最基本的目标之一是建立一些抽象 , 以使系统方便易用 . **抽象**是我们在计算机科学中所做的一切的基础 . 抽象让编写一个大型程序成为可能 , 其将大型程序分成小而易懂的部分 , 用像C9这样的高级语言编写这样的程序 , 而无需考虑**程序集** , 在汇编中编写代码而不考虑**逻辑门 **, 并在不考虑晶体管的情况下, 在门外构建处理器 . 抽象是如此的根本 , 有时我们忘记它的重要性 , 这里我们只是简单的介绍 , 在之后每一节中 , 我们将讨论一些随着时间的推移而发展的主要抽象 , 让你能够思考操作系统的各个部分 , 更好的理解 .

> **程序集** , 经由编译器编译得到的 , 供CLR进一步编译执行的那个中间产物 , 在WINDOWS系统中 , 它一般表现为·dll或者是·exe的格式 . 但是要注意 , 它们跟普通意义上的WIN32可执行程序是完全不同的东西 , 程序集必须依靠CLR才能顺利执行 .
>
> **逻辑门**\(Logic Gates\)是在集成电路上的基本组件 .

设计和实现操作系统的一个目标是提供高性能 . 另一种说法是 , 尽量减少操作系统的开销 . 虚拟化和使系统易于使用是非常值得的 , 但不是不惜任何代价 . 因此 , 我们必须努力提供虚拟化和其他操作系统功能 , 而无需过多的开销 . 这些开销以多种形式出现 : 额外的时间\(更多的指令\)和额外的空间\(在内存或磁盘上\)如果可能 , 我们将寻求最小化一个或另一种的解决方案 . 然而 , 完美并不总是存在的 ,  注意 , 我们要学会\(在适当的情况下\)容忍 .

另一个目标是在应用程序之间以及在操作系统和应用程序之间提供保护 . 因为我们希望允许多个程序同时运行 , 所以我们要确保一个人的恶意或偶然的不良行为不会伤害他人 . 我们当然不希望应用程序能够损害操作系统本身\(因为这会影响系统上运行的所有程序\) . 保护是操作系统的主要原则之一 , 也就是隔离的核心 . 将进程彼此隔离是保护的关键 , 因此是操作系统必须执行的大部分任务 .

操作系统也必须不间断运行 . 当它失败时 , 系统上运行的所有应用程序也会失败 . 由于这种依赖性 , 操作系统往往力求提供高度的可靠性 . 随着操作系统变得越来越复杂\(有时包含数百万行代码\) , 构建一个可靠的操作系统是一个相当棘手的问题 . 事实上 , 这个领域的许多研究都专注于这个确切的问题 .

其他有意义的目标 . 在我们越来越绿色的世界中 , 节能也是很重要的 . 还有安全性 , 真正的保护扩展对于恶意应用程序至关重要 , 特别是在这些高度网络化的时代 . 移动性也越来越重要 , 因为操作系统在越来越小的设备上运行 . 根据系统的使用方式 , 操作系统将有不同的目标 , 至少可能略有不同 . 但是 , 正如我们将要看到的 , 我们将介绍的关于如何构建操作系统的许多原则在各种不同的设备上都是很有用的 .

#### 一些历史

篇幅原因 , 转移到扩展阅读 , 还有后面的文章 .

#### 总结

至此 , 我们已经对操作系统做了一个大体的介绍 . 如今的操作系统已经相对易于使用了 , 我们在整本书中会讨论到现今几乎所有的操作系统 , 也许会给你今后使用操作系统带来深远的影响 .

但是很不幸 , 由于时间的限制 , 还有一部分的操作系统本书不会涉及 . 比如 , 操作系统的许多网络部分的内容 , 我们会在学习网络的时候提供资料让你去了解更多 . 同样的 , 图像设备是特别重要的 , 可以学习显卡方面的知识来扩展这方面的知识 . 最后 , 有些操作系统一大堆安全有关的东西 , 我们在程序运行和给用户提供交互能力的时候谈论一下OS必须提供的保护文件的保护机制 , 但我们不会深入到更深层次的安全问题 , 因为那些是属于安全方面的 .

不过 , 我们还是涵盖了很多重要的主题 , 包括并发 , 虚拟化CPU和内存的基本知识 , 还有设备文件的持久性 . 所以不必担心 , 这里还是涵盖了很多方面的 , 很多知识内容很酷 , 而且在学习结束的时候 , 你将会对电脑系统正在的工作有一个新的认识 . 现在开始学习吧 !

