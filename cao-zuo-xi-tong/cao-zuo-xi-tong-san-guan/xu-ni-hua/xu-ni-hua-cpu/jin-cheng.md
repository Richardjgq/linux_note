# 进程

#### **抽象化 : 进程**

在本章节中 , 我们将讨论一个在计算机系统中最基本的抽象化概念 : **进程** . 简单的说 , 进程的定义非常简单 : 就是一个正在运行程序 . 程序本身是一个没有生命的东西 , 他就只是存在于磁盘上 , 由一系列的指令或者更为简单的基本数据构成 , 等待着去被启动 . 是操作系统取出这些指令 , 然后投入运行 , 将普通的程序变成有用的东西 .

事实证明 , 我们经常想要在同一时间运行多个程序 . 举个例子 , 例如在你的桌面 , 或者你的笔记本上 , 可能要开一个浏览器 , 一个邮件应用 , 一个游戏 , 一个音乐播放器等等 . 实际上 , 一个普通的系统 , 通常似乎可以同时运行几十甚至上百个程序 . 这样就使得系统比较易于使用 , 简化了程序运行 , 不要考虑是不是只有一个CPU , 现在这个程序能否使用CPU .

我们面临的问题 :

* 如何创造这种多个CPU的假象 ? 
* 尽管只有很少的几个CPU , OS怎么提供一个似乎是有用不完的CPU的环境 ? 

OS通过虚拟化CPU创造出来这样的环境 . 通过运行一个程序 , 然后停止这个程序再去运行另一个程序 , 如此 , OS就能保证许多虚拟CPU的存在 , 虽然实际上只有一个\(或几个\)物理CPU . 这个基本的技术 , 被称为**CPU分时共享** , 这样用户可以任意允许多个并发的进程 . 这个基本的代价就是**性能** , 如果CPU必须被共享 , 那么每个程序都会运行的很慢 .

为了很好的实现CPU的虚拟化 , 操作系统既要有一些低级机构 , 也需要一些高级的智能 . 我们将这些低级机构称为**机制** . 机制的定义 : 就是一些低级的方法或者协议 , 用于实现某种功能性的需要 . 例如 , 我们后面将要学习的上下文切换 , 这是操作系统在有一个CPU的情况下暂停一个程序去启动另一个程序的能力 , 现在的操作系统都采用了这种分时机制 .

**Tips : 使用分时\(和分区\)**

**分时 : **分时是操作系统用来共享资源的一种基本技术 . 让一个实体使用资源一段时间 , 然后另一个再占用资源一段时间 , 如此往下 , 这些有争议的资源\(如CPU , 网络\)就可以被很多对象所共用 . 与分时自然而然对应起来的就是**分区**了 . 在空间上将资源分配给那些想要使用它的 . 举个例子 , 磁盘空间自然就是一个空间共享\(分区\)的资源 , 一旦一个块区被分配给一个文件了 , 那另一个文件想要使用磁盘 , 并不需要等到用户吧原来那个存在磁盘上的文件给删了 .

操作系统中 , 这些机制以策略的形式存留了一些高级的智能 . 策略就是操作系统中用于决策的算法库 . 例如 : 给出一些可能在一个CPU上运行的程序 , 操作系统应该运行哪一个程序 ? 调度策略会帮操作系统来作决定 , 也许就是根据历史信息\(比如哪个程序是最后一分钟运行的\) , 工作量信息\(比如程序运行的形式\) , 表现形式\(比如系统是否优化了交互性能或者吞吐量\) , 这些信息就是决策的依据 .

#### 进程API

虽然我们打算在后面的章节中再介绍一下真正的进程API , 但是这里还是有必要给出一个操作系统接口的一些概念 . 在现代操作系统中 , 这些API我们都可以以一些形式获取 . 

**创建 : **一个操作系统必须有一些创建新进程的方法 . 当你在shell脚本中写入一个命令 , 或者双击某个应用的图标 , 操作系统就被调用去创建一个进程 , 来运行你指定好的程序 . 

**销毁 : **就像进程的创建有一个接口一样 , 操作系统也提供了一个强制销毁进程的接口 . 当然 , 很多进程都会在他们运行完成的时候自动退出 . 然而 , 当他们不自动退出的时候 , 用户或许会想要终止他们 , 因此一个可以终止不可控进程的接口是相当有用的 . 

**等待 : **有时候等待一个进程结束运行时很有用的 . 因此 , 很多时候也提供了一些等待的接口 . 

**混合控制 : **除了终止和等待进程 , 有时候也可能需要其他的控制 . 比如 , 大部分操作系统提供了暂停进程的方法\(将运行状态的进程停止一段时间\) , 然后再恢复该进程 \(让进程继续运行\) . 

**状态 : **也经常有一些接口可以获取进程状态信息 , 比如进程运行了多久 , 或者进程现在所处的状态 . 

![](/assets/jincheng.png)



