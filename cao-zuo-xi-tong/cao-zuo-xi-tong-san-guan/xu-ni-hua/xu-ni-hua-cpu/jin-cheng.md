# 进程

在本章节中 , 我们将讨论一个在计算机系统中最基本的抽象化概念 : **进程** . 简单的说 , 进程的定义非常简单 : 就是一个正在运行程序 . 程序本身是一个没有生命的东西 , 他就只是存在于磁盘上 , 由一系列的指令或者更为简单的基本数据构成 , 等待着去被启动 . 是操作系统取出这些指令 , 然后投入运行 , 将普通的程序变成有用的东西 .

事实证明 , 我们经常想要在同一时间运行多个程序 . 举个例子 , 例如在你的桌面 , 或者你的笔记本上 , 可能要开一个浏览器 , 一个邮件应用 , 一个游戏 , 一个音乐播放器等等 . 实际上 , 一个普通的系统 , 通常似乎可以同时运行几十甚至上百个程序 . 这样就使得系统比较易于使用 , 简化了程序运行 , 不要考虑是不是只有一个CPU , 现在这个程序能否使用CPU .

> 我们面临的问题 :
>
> * 如何创造这种多个CPU的假象 ? 
> * 尽管只有很少的几个CPU , OS怎么提供一个似乎是有用不完的CPU的环境 ?

OS通过虚拟化CPU创造出来这样的环境 . 通过运行一个程序 , 然后停止这个程序再去运行另一个程序 , 如此 , OS就能保证许多虚拟CPU的存在 , 虽然实际上只有一个\(或几个\)物理CPU . 这个基本的技术 , 被称为**CPU分时共享** , 这样用户可以任意允许多个并发的进程 . 这个基本的代价就是**性能** , 如果CPU必须被共享 , 那么每个程序都会运行的很慢 .

为了很好的实现CPU的虚拟化 , 操作系统既要有一些低级机构 , 也需要一些高级的智能 . 我们将这些低级机构称为**机制** . 机制的定义 : 就是一些低级的方法或者协议 , 用于实现某种功能性的需要 . 例如 , 我们后面将要学习的上下文切换 , 这是操作系统在有一个CPU的情况下暂停一个程序去启动另一个程序的能力 , 现在的操作系统都采用了这种分时机制 .

> **Tips : 使用分时\(和分区\)**
>
> **分时 : **分时是操作系统用来共享资源的一种基本技术 . 让一个实体使用资源一段时间 , 然后另一个再占用资源一段时间 , 如此往下 , 这些有争议的资源\(如CPU , 网络\)就可以被很多对象所共用 . 与分时自然而然对应起来的就是**分区**了 . 在空间上将资源分配给那些想要使用它的 . 举个例子 , 磁盘空间自然就是一个空间共享\(分区\)的资源 , 一旦一个块区被分配给一个文件了 , 那另一个文件想要使用磁盘 , 并不需要等到用户吧原来那个存在磁盘上的文件给删了 .

操作系统中 , 这些机制以策略的形式存留了一些高级的智能 . 策略就是操作系统中用于决策的算法库 . 例如 : 给出一些可能在一个CPU上运行的程序 , 操作系统应该运行哪一个程序 ? 调度策略会帮操作系统来作决定 , 也许就是根据历史信息\(比如哪个程序是最后一分钟运行的\) , 工作量信息\(比如程序运行的形式\) , 表现形式\(比如系统是否优化了交互性能或者吞吐量\) , 这些信息就是决策的依据 .

#### **抽象化 : 进程**

操作系统对一个正在运行的程序的抽象化 , 我们称之为**进程** . 根据我们前面所说 , 一个进程简单说来就是一个运行中的程序 , 我们可以通过盘点程序在运行中的任意时刻对操作系统的不同部分的访问和造成的影响来概括进程 .

想要了解进程是由什么构成 , 我们需要知道它的**机器状态 , **一个程序运行的时候可以读取或者修改什么 . 在任何给定的时间 , 机器的哪些部分对于程序的执行来说很重要 ?

构成进程的一个很明显的机器状态的组件就是内存 . 程序指令就存放在内存中 , 运行状态中的程序读取和写入的数据也存放在内存中 . 所以内存的程序可用地址\(称之为**地址空间**\)就是进程的一部分 .

机器状态中的寄存器也是构成进程的一部分 . 很多指令明确的读取或者更新寄存器 , 因而对于进程的执行来说他们很重要 .

要知道 , 还有一些尤其特殊的寄存器也是机器状态的组成部分 . 比如 , 程序计数器\(PC , 有时称之为指令集活着IP\)可以告诉我们程序正在运行什么指令 , 同样地 , 一个堆栈指针和关联的帧指针被用来管理函数参数 , 局部变量和返回地址的堆栈 .

> **Tips : 分离策略和机制**
>
> 在很多操作系统中 , 一个常见的范例就是将高级的策略从他们的低级机制中分离出来 . 你可以想象一下这些机制是系统中用于解决问题的答案 . 比如 , 操作系统如何进行上下文切换 ? 策略就给特定的问题提供了答案 . 比如 , 操作系统此刻应该启动哪个进程 ? 将两者分离使得一方可以简单的选择策略而不需要重新考虑机制 . 这是模块化的一种形式 , 一种通用软件的设计原则 .

最后 , 程序也经常访问永久存储设备 . 比如进程中已经打开的I/O信息就可能存在于文件列表中 .

#### 进程API

虽然我们打算在后面的章节中再介绍一下真正的进程API , 但是这里还是有必要给出一个操作系统接口的一些概念 . 在现代操作系统中 , 这些API我们都可以以一些形式获取 .

**创建 : **一个操作系统必须有一些创建新进程的方法 . 当你在shell脚本中写入一个命令 , 或者双击某个应用的图标 , 操作系统就被调用去创建一个进程 , 来运行你指定好的程序 .

**销毁 : **就像进程的创建有一个接口一样 , 操作系统也提供了一个强制销毁进程的接口 . 当然 , 很多进程都会在他们运行完成的时候自动退出 . 然而 , 当他们不自动退出的时候 , 用户或许会想要终止他们 , 因此一个可以终止不可控进程的接口是相当有用的 .

**等待 : **有时候等待一个进程结束运行时很有用的 . 因此 , 很多时候也提供了一些等待的接口 .

**混合控制 : **除了终止和等待进程 , 有时候也可能需要其他的控制 . 比如 , 大部分操作系统提供了暂停进程的方法\(将运行状态的进程停止一段时间\) , 然后再恢复该进程 \(让进程继续运行\) .

**状态 : **也经常有一些接口可以获取进程状态信息 , 比如进程运行了多久 , 或者进程现在所处的状态 .

![](/assets/jincheng.png)

#### **进程创建 : 更多的细节**

首先我们要揭秘的是 , 程序是怎样转换为进程的 . 尤其是 , 操作系统怎么得到一个程序并将之运行 ? 进程创建实际上是怎么作用的 ? 

操作系统想要运行程序时 , 最先要做的事情就是将程序的代码段和数据段\(比如初始化过的变量\)载入进程的内存和地址空间 . 程序最初是以可执行格式存储在磁盘\(或者在现代操作系统中还有基于闪存的固态硬盘\)上的 . 因此 , 载入程序和静态数据进入内存的进程需要操作系统从磁盘读取数据并将它们存放在内存中的某处 , 见上图 . 

在早期简单的操作系统中 , 装载进程很紧急 , 即在程序运行之前一次性全部完成 . 而现代操作系统执行该进程就很慵懒了 , 在程序执行过程中只载入需要用的代码片段和数据 . 为了真正了解载入代码和数据片段有多懒 , 你需要了解机器中的分页机制和调度机制 , 这个专题我们将放在在后续有关内存虚拟化的讨论中 . 现在只要记得 , 在运行任何程序之前 , 操作系统必须做一些工作来从磁盘获取重要的程序数据放入内存 . 

一旦代码段和静态数据被装入内存以后 , 操作系统在启动进程之前还需要做一些其他的事情 . 一部分的内存空间需要分配给程序的运行时堆栈\(或者也就是堆栈\) . 或许你应该已经知道 , C语言程序将堆栈用来存放局部变量 , 功能参数以及返回地址 . 操作系统将内存进行划分并将之交给进程 . 操作系统似乎也初始化了带参的堆栈 , 尤其是它会将这些参数传入main\(\)函数中 , 即argc和argv数组 . 

```
int main(int argc,char **argv);
argc表示参数个数
argv数组中存放的是参数的具体内容
argc可用在main函数中作为参数个数的检查
```

操作系统也会分配一些内存空间给程序的堆 . 在C语言中 , 堆空间用于需求明确的动态分配空间的数据 , 程序通过调用malloc\(\)函数来申请一块大小明确的空间 , 然后通过调用free\(\)函数再准确的释放掉该空间 . 堆空间通常被一些数据结构所使用 , 如链表 , 哈希表 , 树和其他一些很有趣的数据结构 . 首先堆空间会变小 , 随着程序的运行和malloc\(\)库函数对空间的分配 , 操作系统可能会介入并分配更多的内存空间给进程来满足这些需求 . 

操作系统还会做其他一些初始化的工作 , 尤其是I/O\(input/output输入输出流 , 用于数据读取写入等\)相关的 . 比如 , 在UNIX系统中 , 每个默认进程都拥有三个文件描述符 , 标准输入\(stdin\) , 标准输出\(stdout\)和标准错误\(stderr\) . 这些描述符使得程序轻松的从终端读取输入的数据并将输出结果打印到显示器 . 我们将在本书的第三部分 , 持续性的部分学习I/O , 文件描述符等 . 

通过载入代码和静态数据进入内存 , 通过创建和初始化栈 , 通过执行与I/O相关的操作这些步骤 , 操作系统最终为程序的执行做好铺垫了 . 至此 , 它还有最后一个任务 , 在程序入口处启动程序 , 也就是main\(\)函数处 . 通过跳转至main\(\)函数的路线\(通过一个特殊的机制 , 将在下一章讨论\) , 操作系统将对CPU的控制权交给一个新建的进程 , 此时程序开始执行 . 

